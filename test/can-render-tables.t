Generate the ppx_deriving_yaml documentation

  $ voodoo-prep 2> /dev/null

  $ voodoo-do -p ppx_deriving_yaml -b 2> /dev/null

  $ voodoo-gen -o output
  0 other versions, 1 packages
  Found 2 files

Generates a status.json file
  $ cat output/p/ppx_deriving_yaml/0.2.1/status.json | jq .
  {
    "failed": false,
    "otherdocs": {
      "readme": [
        "linked/p/ppx_deriving_yaml/0.2.1/doc/README.md"
      ],
      "license": [
        "linked/p/ppx_deriving_yaml/0.2.1/doc/LICENSE.md"
      ],
      "changes": [
        "linked/p/ppx_deriving_yaml/0.2.1/doc/CHANGES.md"
      ],
      "others": [
        "linked/p/ppx_deriving_yaml/0.2.1/package.json"
      ]
    },
    "broken_link_files": []
  }

Generate a README.md file with the tables formatted in HTML
  $ cat output/p/ppx_deriving_yaml/0.2.1/README.md.html.json | jq '.content'
  "<p>This ppx is based on <a href=\"https://github.com/NathanReb/ppx_yojson\">ppx_yojson</a> and <a href=\"https://github.com/ocaml-ppx/ppx_deriving_yojson\">ppx_deriving_yojson</a> because of the many similarities between JSON and yaml. In particular many of the way the OCaml values are encoded to yaml types are the same as those implemented by the Yojson ppx.</p><ul><li><p><a href=\"#basic-usage\">Basic Usage</a></p></li><li><p><a href=\"#attributes\">Attributes</a></p><ul><li><p><a href=\"#key-and-name\">Key and Name</a></p></li><li><p><a href=\"#default-values\">Default Values</a></p></li><li><p><a href=\"#custom-encoding-and-decoding\">Custom encoding and decoding</a></p></li></ul></li><li><p><a href=\"#partially-decoding\">Partially Decoding</a></p></li><li><p><a href=\"#implementation-details\">Implementation Details</a></p></li></ul><h3>Basic Usage</h3><p>For converting OCaml values to yaml values <code>ppx_deriving_yaml</code> will do the conventional dropping of the type name if it is <code>t</code>. Otherwise the type name is the prefix to the <code>to_yaml</code> function.</p><p><code>to_yaml</code> produces a <a href=\"https://github.com/avsm/ocaml-yaml/blob/master/lib/types.ml#L44\"><code>Yaml.value</code></a> which is compatible with the <a href=\"https://github.com/mirage/ezjsonm/blob/master/lib/ezjsonm.ml#L18\"><code>Ezjsonm.value</code></a> type.</p><p><code>of_yaml</code> produces OCaml types wrapped in a <code>result</code> -- this is how ocaml-yaml also handles errors i.e. not using exceptions. Based on your type this should let you move between yaml and OCaml values.</p><pre class=\"language-markdown\"><code># #require &quot;ppx_deriving_yaml&quot;;;\n</code></pre><p>Here is a small example.</p><pre class=\"language-markdown\"><code>type person = { name : string; age : int } [@@deriving yaml]\ntype users = person list [@@deriving yaml]\n</code></pre><p>This will produce four functions, a <code>_to_yaml</code> and <code>_of_yaml</code> for both a person and<br/>the users. For example:</p><pre class=\"language-markdown\"><code># person_to_yaml;;\n- : person -&gt;\n    [&gt; `O of (string * [&gt; `Float of float | `String of string ]) list ]\n= &lt;fun&gt;\n# users_of_yaml;;\n- : [&gt; `A of [&gt; `O of (string * Yaml.value) list ] list ] -&gt;\n    (person list, [&gt; `Msg of string ]) result\n= &lt;fun&gt;\n</code></pre><p>If you make polymorphic types, then you will have to supply the function to convert the unknown to a yaml value. For example:</p><pre class=\"language-markdown\"><code>type 'a note = { txt : 'a } [@@deriving yaml]\n</code></pre><p>produces the following function.</p><pre class=\"language-markdown\"><code># note_to_yaml;;\n- : ('a -&gt; Yaml.value) -&gt; 'a note -&gt; [&gt; `O of (string * Yaml.value) list ] =\n&lt;fun&gt;\n</code></pre><p>Finally, if you only need the encoder (<code>to_yaml</code>) or the decoder (<code>of_yaml</code>) then there are single versions of the deriver for those.</p><pre class=\"language-markdown\"><code># type x = { age : int }[@@deriving to_yaml];;\ntype x = { age : int; }\nval x_to_yaml : x -&gt; [&gt; `O of (string * [&gt; `Float of float ]) list ] = &lt;fun&gt;\n</code></pre><h3>Attributes</h3><h4>Key and Name</h4><p>Record field names cannot begin with a capital letter and variant constructors must start with one. This limits what the generated yaml can look like. To override the yaml names you can use the <code>[@key &lt;string&gt;]</code> and <code>[@name &lt;string&gt;]</code> attributes for records and variants respectively.</p><p>For example:</p><pre class=\"language-markdown\"><code>type t = {\n  camel_name : string [@key &quot;camel-name&quot;]\n}[@@deriving to_yaml]\n</code></pre><p>Will produce Yaml of the form</p><pre class=\"language-markdown\"><code># Yaml.to_string (to_yaml { camel_name = &quot;Alice&quot; });;\n- : string Yaml.res = Ok &quot;camel-name: Alice\\n&quot;\n</code></pre><h4>Default Values</h4><p>You can also specify default values for fields.</p><pre class=\"language-markdown\"><code>type t = {\n  name : string;\n  age : int [@default 42]\n}[@@deriving yaml]\n</code></pre><p>These will be used in the absence of any fields when decoding yaml values into OCaml ones.</p><pre class=\"language-markdown\"><code># Yaml.of_string_exn &quot;name: Alice&quot; |&gt; of_yaml;;\n- : (t, [&gt; `Msg of string ]) result = Ok {name = &quot;Alice&quot;; age = 42}\n</code></pre><h4>Custom encoding and decoding</h4><p>Sometimes you might want to specify your own encoding and decoding logic on field<br/>by field basis. To do so, you can use the <code>of_yaml</code> and <code>to_yaml</code> attributes.</p><pre class=\"language-markdown\"><code>type t = {\n  age : int [@to_yaml fun i -&gt; `Float (float_of_int (i + 1))]\n}[@@deriving yaml]\n</code></pre><p>The <code>to_yaml</code> function will use the custom encoder now instead.</p><pre class=\"language-markdown\"><code># Yaml.to_string (to_yaml { age = 41 });;\n- : string Yaml.res = Ok &quot;age: 42\\n&quot;\n</code></pre><h3>Partially Decoding</h3><p>There is a <code>~skip_unknown</code> flag for telling the deriver to simply ignore any fields which are missing. This is particularly useful when you only wish to partially decode a yaml value.</p><p>Consider the following yaml:</p><pre class=\"language-markdown\"><code>let yaml = &quot;name: Bob\\nage: 42\\nmisc: We don't need this!&quot;\n</code></pre><p>If we try to do the normal decoding of this but only partially extract the fields, it will throw an error.</p><pre class=\"language-markdown\"><code>type t = {\n  name : string;\n  age : int;\n}[@@deriving yaml]\n</code></pre><p>Note that the error is often rather confusing. There is room for improvement (PRs welcome!).</p><pre class=\"language-markdown\"><code># Yaml.of_string_exn yaml |&gt; of_yaml;;\n- : (t, [&gt; `Msg of string ]) result =\nError (`Msg &quot;miscWe don't need this!\\n&quot;)\n</code></pre><p>Instead we tell the deriver to ignore unknown fields.</p><pre class=\"language-markdown\"><code>type t = {\n  name : string;\n  age : int;\n}[@@deriving yaml ~skip_unknown]\n</code></pre><pre class=\"language-markdown\"><code># Yaml.of_string_exn yaml |&gt; of_yaml;;\n- : (t, [&gt; `Msg of string ]) result = Ok {name = &quot;Bob&quot;; age = 42}\n</code></pre><h3>Implementation Details</h3><p>One important thing is that <code>'a option</code> values within records will return <code>None</code> if the Yaml you are trying to convert does not exist.</p><table>\n<thead>\n<tr>\n<th align=\"center\">OCaml Type</th>\n<th align=\"center\">Yaml Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code>int</code></td>\n<td align=\"center\"><code>`Float</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>float</code></td>\n<td align=\"center\"><code>`Float</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><code>`String</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>bool</code></td>\n<td align=\"center\"><code>`Bool</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>None</code></td>\n<td align=\"center\"><code>`Null</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>list</code></td>\n<td align=\"center\"><code> `A []</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>array</code></td>\n<td align=\"center\"><code> `A []</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>record</code> e.g <code>{ name : string }</code></td>\n<td align=\"center\"><code>`O [(&quot;name&quot;, `String s)]</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>A of int</code> or <code> [`A of int]</code></td>\n<td align=\"center\"><code>`O [(&quot;A&quot;, `A [`Float f])]</code></td>\n</tr>\n</tbody>\n</table>\n"
